#!/bin/sh
# (c) 2013-2015 Косырев Сергей <_deepfire@feelingofgreen.ru>
# Licensed under the terms of the GNU GPL License version 3 and higher

# set -e

error() {
	echo "ERROR: $1" >&2
	exit 1
}

## Context library
CTX_STORE=.git/weld-context
CTX_CMDLINE="$@"
ctx_path() {
	echo ${CTX_STORE}
}
ctx_present_p() {
	test -f ${CTX_STORE}
}
ctx_save_var() {
	local var="$1"
        eval "echo \"${var}=\\\"\${$var}\\\"\"" >> ${CTX_STORE}
}
ctx_commit_phase() {
	local phase=$1
	eval "$1=t"
	ctx_save_var ${phase}
}
if ctx_present_p
then CTX_STORED_CMDLINE="($(grep CTX_CMDLINE ${CTX_STORE}))"
fi

do_exit() {
	local exit_status=$1
	local operation="$2"


	if test ${exit_status} = 0
	then echo "; weld: successful '${operation}'"
	     rm $(ctx_path)
	else echo "; weld: FAILED '${operation}'" >&2
	fi

	exit ${exit_status}
}

usage() {
    test -z "$1" || echo "ERROR: $1"

    cat <<EOF
  Usage:
    $0 OPTIONS* TO-COMMIT [FROM-COMMIT]

  "Welds" FROM-COMMIT into TO-COMMIT, then rebases the current branch
  (unless another is specified) atop the new commit.

  When COMMIT is not specified, it is interpreted
  as the tip of HEAD.

  When COMMIT equals to a special value "tree", a new commit is made,
  using 'git add --all', atop HEAD, which is then used as a value
  for the parameter.

   Modes of   Elementary actions:
  operation:
              cherry weld amend REBASE_BASE   command line

    weld         +     +    +      TO+1                                          <to> <from>
    weldit       -     -    +      TO+1    --no-cherry --no-weld --edit          <to>
    weldname     -     -    +      TO+1    --reauthor <nickname>                 <to>
    weldui       -     -    +      TO+X    --no-cherry --no-weld --manual-amend  <to>
    weldmove     +     -    -      TO+1    --no-weld --no-amend                  <to> <from>
    weldrop      -     -    -      TO^1    --drop-commit                         <to>

  Options:

    --branch BRANCH    Use a branch different from HEAD
    --edit[-message]   Allow editing of the amended commit message
    --manual-amend     Run git-gui for amending.  Conflicts with --no-amend
    --no-move          Do not move to TO
    --no-cherry[pick]  Do not cherry-pick FROM-COMMIT
    --no-weld          Do not weld FROM-COMMIT onto TO-COMMIT
    --no-amend         Do not amend TO-COMMIT.  Conflicts with --edit-message
    --no-mutate        History rewrite mode only, do not change any commits
                         Shortcut for --no-{move,cherry,weld,amend}
    --reauthor[-commit] NICKNAME
                       Change author of TO-COMMIT to NICKNAME.
    --drop[-commit]    Drop TO-COMMIT.  Implies --no-mutate

    --non-continuable  Always abort on failure, do not suggest --continue.
    --continuable      When either a cherry-pick, or a rebase fails, do not
                         disturb the state of failure with weld abort operations
    --continue         Restore weld session from ${CTX_STORE} ${CTX_STORED_CMDLINE}
    --abort            Abort weld session

    --debug-vars       Print internal variables
    --debug-keep       Keep the temporary branches
    --trace            Trace command invocation

    --help             This.
EOF
}

help_continuable() {
	local title="$1"
	cat <<EOF
   ${title}

      0. Abort not performed:
          - conflict are in the tree
          - temporary weld branches are out there

      1. It allows you to:
          - fix the conflicts manually
          - 'git add' deconflicted files
          - resume weld:  'weld --continue'

      2. Lost hope?  Still can ABORT later by 'weld --abort'

EOF
}

git_head_ref_shortname() {
    echo $1 | sed s%refs/heads/%%
}

git_move_branch() {
	local branch="$1"
	local to="$2"

        git checkout --quiet ${branch}
        git reset --hard ${to}
}

git_kill_branch() {
	local branch="$1"

	git branch -D ${b} 2>/dev/null || true
}

ABORT=
CONTINUE=

GIT_AMEND_NO_EDIT_MESSAGE="--no-edit"
GIT_AMEND_AUTHOR=""

ORIG_HEAD="$(git symbolic-ref HEAD)"
BRANCH="${ORIG_HEAD}"

while test -z "${opt_done}"
do
    case "$1"
        in
	--non-continuable )                   NON_CONTINUABLE=t;
					      test -z "${CONTINUABLE}" ||
						  error "--continuable provided with --non-continuable";;
        --continuable )                       CONTINUABLE=t;
					      test -z "${NON_CONTINUABLE}" ||
						  error "--continuable provided with --non-continuable";;
	--continue )                          CONTINUE=t;
					      test -z "${ABORT}" ||
						  error "--continue provided with --abort";;
	--abort )                             ABORT=t;
					      test -z "${CONTINUE}" ||
						  error "--continue provided with --abort";;
        --edit | --edit-message )             GIT_AMEND_NO_EDIT_MESSAGE="";;
        --no-move )                           NO_MOVE=t;;
        --no-cherry | --no-cherrypick )       NO_CHERRY=t;;
        --no-weld )                           NO_WELD=t;;
        --no-amend )                          NO_AMEND=t;;
        --manual-amend )                      MANUAL_AMEND=t;;
        --debug-vars )                        DEBUG_VARS=t;;
        --debug-keep )                        DEBUG_KEEP=t;;
	--trace )                             TRACE=t;;
        --branch )
            BRANCH="refs/heads/$2"
            git show-ref --quiet --verify ${BRANCH} ||
	        error "not a local branch: $2"
            shift
            ;;
        --no-mutate )
            NO_MOVE=t
            NO_CHERRY=t
            NO_WELD=t
            NO_AMEND=t
            ;;
        --reauthor | --reauthor-commit )
            REAUTHOR_COMMIT=t
            NO_CHERRY=t
            NO_WELD=t
            full_id="$(author-id $2)"
            if test -z "${full_id}"
            then
	        error "unknown author id: $2"
            else
                echo "; weld: resolved author id <$2> to ${full_id}"
            fi
            shift
            GIT_AMEND_AUTHOR="--author \"${full_id}\""
            ;;
        --drop | --drop-commit )
            DROP_COMMIT=t
            NO_MOVE=t
            NO_CHERRY=t
            NO_WELD=t
            NO_AMEND=t
            ;;
	--help )
	    usage; exit 1
	    ;;
        "--"* )
            error "unknown option: $1"
            ;;
        * )
            break
            ;;
    esac
    shift
done

###
### Context  (WARNING: doesn't contain NON_CONTINUABLE, CONTINUE and ABORT !)
###
CTX_VARS="BRANCH TO FROM ORIG_HEAD REBASE_BASE CONTINUABLE NO_MOVE NO_CHERRY NO_WELD NO_AMEND REAUTHOR_COMMIT DROP_COMMIT MANUAL_AMEND GIT_AMEND_NO_EDIT_MESSAGE GIT_AMEND_AUTHOR DIFF_REAPPLY_ON_ERROR REBASE_BASE_BRANCH BRANCH_BACKUP CTX_CMDLINE"

if test -z "${CONTINUE}" -a -z "${ABORT}"
then
    TO="$1"

    test -z "${TO}" && {
	usage "TO argument is empty"
	exit 1
    }

    if test "$2" = "tree"
    then
	test x${TRACE} == x || set -x
	git add --all
	DIFF_REAPPLY_ON_ERROR="saved-tree-${RANDOM}"
	git branch "${DIFF_REAPPLY_ON_ERROR}"
	git commit -m "working tree at ${ORIG_HEAD}"
	FROM="$(git show-ref --verify ${ORIG_HEAD} | cut -d' ' -f1)"
	echo "; weld: saved working tree as commit ${FROM}"
	git reset --hard HEAD^1
	set +x
    else
	FROM="${2:-${BRANCH}}"
	if test -z "$2${NO_WELD}"
	then
            echo "; weld: FROM assumed to be tip of branch ${BRANCH}"
	fi
    fi

    if git status --porcelain 2>&1 | grep "^??" > /dev/null
    then
	echo "FATAL: unstaged changes in working tree -- safe operation impossible."
	exit 1
    fi

    if test ! -z "${DROP_COMMIT}"
    then
	REBASE_BASE=${TO}^1
    else
	REBASE_BASE=${TO}
    fi

    REBASE_BASE_BRANCH="rebase-weld-${RANDOM}"
    BRANCH_BACKUP="backup-weld-${RANDOM}"

    rm -f ${CTX_STORE}
    for var in ${CTX_VARS}
    do ctx_save_var ${var}
    done
else
    echo "; weld: restoring context from ${CTX_STORE}"
    source ${CTX_STORE}
fi

if test ! -z "${DEBUG_VARS}"
then
    echo "; weld: internal state:"
    for var in ${CTX_VARS}
    do
        eval "echo \"    $var: \${$var}\""
    done
fi

test x${TRACE} == x || set -x

###
### Abort library
###
abort_restore_user_context() {
	git_move_branch $(git_head_ref_shortname ${BRANCH}) ${BRANCH_BACKUP}
        git checkout --quiet $(git_head_ref_shortname ${ORIG_HEAD})
	test -z "${DIFF_REAPPLY_ON_ERROR}" || {
		git cherry-pick --no-commit ${DIFF_REAPPLY_ON_ERROR}
		git_kill_branch ${DIFF_REAPPLY_ON_ERROR}
	}
}

abort_remove_weld_branches() {
	local cleanup_branches="$*"
	test ! -z "${DEBUG_KEEP}" ||
		for b in ${cleanup_branches}
		do
			git_kill_branch ${b}
		done
}

abort() {
	local abort_command="$1"; shift
	local cleanup_branches="$*"

	echo "; weld: aborting operation"
	${abort_command}
	abort_restore_user_context
	abort_remove_weld_branches ${cleanup_branches}
}

###
### Continuation support
###
maybe_continuable() {
	local failed_action="$1"
	local abort_command="$2"
	local cleanup_branches="$3"

	cat <<EOF
WARNING
WARNING  ${failed_action} failed.
WARNING

EOF
	if test ! -z "${NON_CONTINUABLE}"
	then abort "${abort_command}" ${cleanup_branches}; return
	fi

	local fixp=
	help_continuable "Do you want to FIX-manually-then-continue?  If you do, then:"
	if test ! -z ${CONTINUABLE}
	then
		fixp=f
	else
		echo "FIX-manually-then-continue, or ABORT?"
		echo -n "Your choice?  'f'IX / 'a'BORT=default  "
		read fixp
	fi
	if test x$fixp != xf # User declined to use fixup-then-continue
	then
		echo "You chose ABORT"
		abort "${abort_command}" ${cleanup_branches}; return
	fi
	echo "You chose FIX"

	## Save the extra state needed for --abort to work:
	ABORT_COMMAND="${abort_command}"
	CLEANUP_BRANCHES="${cleanup_branches}"
	ctx_save_var ABORT_COMMAND
	ctx_save_var CLEANUP_BRANCHES

	if test -z ${CONTINUABLE}
	then # Repeat the help message briefly:
		echo ";"
		echo "; Conflicts left in-place -- fix them, 'git add' fixed, then run"
		echo ";    weld --continue"
		echo ";"
		echo "; ..or, in despair:"
		echo ";    weld --abort"
		echo ";"
	fi
}

### 0: continuation:  handle --abort and --continue
###
if test ! -z "${ABORT}"
then
	abort "${ABORT_COMMAND}" ${CLEANUP_BRANCHES}
	do_exit 0 'abort'
elif test ! -z "${CONTINUE}"
then
	ctx_present_p || error "--continue requires that context is present in $(ctx_path)"
	echo "WARNING:  restoring context from $(ctx_path)"
	. $(ctx_path)
	echo "WARNING:  context restored:  going to skip successful phases and resume failed operation"
fi

### 1: backup user branches, move -- updates HEAD
###
if test -z "${PHASE1_BUBM_DONE}"
then
	git branch ${BRANCH_BACKUP}      ${BRANCH}
	git branch ${REBASE_BASE_BRANCH} ${REBASE_BASE}
	if test -z "${NO_MOVE}"
	then
		git checkout --quiet ${REBASE_BASE_BRANCH}
	fi
	ctx_commit_phase PHASE1_BUBM_DONE
fi

### 2: cherrypick -- updates REBASE_BASE_BRANCH
###
gif test -z "${PHASE2_CHERRY_DONE}" -a -z "${NO_CHERRY}"
then
    echo "; weld: now at ${REBASE_BASE_BRANCH}/${REBASE_BASE}"
    echo "; weld: git cherry-pick ${FROM}"
    if !          git cherry-pick ${FROM}
    then
	maybe_continuable "Cherry-pick ${FROM} on ${REBASE_BASE}" "git cherry-pick --abort" "${REBASE_BASE_BRANCH} ${BRANCH_BACKUP}"
	set +x
        do_exit 1 "cherry-pick ${FROM}"
    fi
    ctx_commit_phase PHASE2_CHERRY_DONE
fi

### 3: reset+add -- updates index
###
if test -z "${PHASE3_MUTATE_DONE}" -a test -z "${NO_WELD}"
then
    test x${TRACE} != x || \
	echo "; weld: git reset --mixed ${TO}"
    git reset --mixed ${TO}
    git add --all
    ctx_commit_phase PHASE3_MUTATE_DONE
fi

### 4: amend+commit -- updates REBASE_BASE_BRANCH
###
if -z "${PHASE4_AMEND_DONE}" -a test -z "${NO_AMEND}"
then
    if test ! -z "${MANUAL_AMEND}"
    then
        git gui
    else
        eval git commit --amend ${GIT_AMEND_NO_EDIT_MESSAGE} ${GIT_AMEND_AUTHOR}
    fi
    ctx_commit_phase PHASE4_AMEND_DONE
fi

### 5: rebase
###
STATUS=0
test x${TRACE} != x || \
    echo "; weld: git rebase --onto ${REBASE_BASE_BRANCH} ${TO} $(git_head_ref_shortname ${BRANCH})"
if                git rebase --onto ${REBASE_BASE_BRANCH} ${TO} $(git_head_ref_shortname ${BRANCH})
then
    ## Safety check:
    git diff --exit-code ${BRANCH_BACKUP} ${BRANCH} || {
        while true
        do
            echo "WARNING: rebase produced differences.  What to do:"
            echo -e "\n   [r]eview/[a]ccept or [any-key] to abort:"
            echo -ne "\n  Your choice: "
            read choice
            case "${choice}" in
                r )
                    git diff --exit-code ${BRANCH_BACKUP} ${BRANCH} | less;;
                a )
                    break;;
                * )
                    STATUS=1
                    break;;
            esac
        done
        if test "${STATUS}" = 1
        then
            ## Undo the successful rebase that was rejected by user:
	    git reset --hard
	    abort_restore_user_context
        fi
    }
    abort_remove_weld_branches ${BRANCH_BACKUP} ${REBASE_BASE_BRANCH}
else
    maybe_continuable "Rebase phase" "git rebase --abort" "${BRANCH_BACKUP} ${REBASE_BASE_BRANCH}"
    STATUS=1
fi

set +x
do_exit ${STATUS} 'rebase'
